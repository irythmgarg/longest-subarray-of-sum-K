Theory
Problem Statement:
Given an array arr and an integer 
ğ‘˜
k, the goal is to find the length of the longest subarray whose elements sum up to 
ğ‘˜
k.

Approach:

Use a hash map to store the prefix sums and their corresponding indices.
The prefix sum is the cumulative sum of elements from the start of the array up to the current position.
For any subarray sum 
ğ‘†[ğ‘–:ğ‘—]
S[i:j]:ğ‘†[ğ‘–:ğ‘—]=
prefix_sum[ğ‘—]âˆ’
prefix_sum[ğ‘–âˆ’1]
S[i:j]=prefix_sum[j]âˆ’prefix_sum[iâˆ’1]
If ğ‘†[ğ‘–:ğ‘—]=ğ‘˜
S[i:j]=k, then:
prefix_sum[ğ‘—]âˆ’
prefix_sum
âˆ’1]=ğ‘˜
prefix_sum[j]âˆ’prefix_sum[iâˆ’1]=k
Rearranging:
prefix_sum[ğ‘–âˆ’1]=
prefix_sum
[ğ‘—]âˆ’ğ‘˜
prefix_sum[iâˆ’1]=prefix_sum[j]âˆ’k
The hash map stores these prefix sums and helps efficiently check for this condition.
Algorithm:

Traverse the array while maintaining a cumulative sum.
If the cumulative sum equals 
ğ‘˜
k, update the maximum length to the current index + 1.
Check if 
sum
âˆ’
ğ‘˜
sumâˆ’k exists in the hash map:
If yes, calculate the subarray length and update the maximum length.
Store the sum in the hash map with its index if it is not already present (to ensure the longest subarray is found).
Return the maximum length.
Complexity:

Time Complexity: 
ğ‘‚(ğ‘›)
O(n), where 
n is the size of the array. Each element is processed once.
Space Complexity: 
ğ‘‚
(
ğ‘›
)
O(n), for the hash map storing prefix sums.
